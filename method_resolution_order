# Method Resolution Order (MRO) - Порядок разрешения методов

#       A
#      / \
#     B   C
#      \ /
#       D

# У нас есть класс А, от него унаследованно классы B, C. Класс D унаследован от обоих классов

class A:
    def some_method(self):
        print('Method of class A')


class B(A):
    def some_method(self):
        print('Method of class B')


class C(A):
    def some_method(self):
        print('Method of class C')


class D(B, C):
    @classmethod
    # методы уровня класса можно назвать статическими методами,
    # потому что в отличие от методов уровня объекта, они используются без создания
    # объекта. Мы не используем никакой атрибут, который индивидуален для каждого объекта,
    # то можно сделать этот метод методом класса @classmethod и ничего не изменится
    def some_method(cls):
        print('Method of class D')
    # Если в методе не используются никаких атрибутов, которые у каждого объекта разные,
    # а используется общий код для всего класса, который распечатывается, возможно создавать методы
    # уровня класса

#  __mro__, mro(), help()

print(D.__mro__)
print(D.mro())
# help(D)
# Если есть одноименной методы в этих классах, то сначала будет вызван класс D,
# если нет этого метода, будет вызван класс B, если нет B, то вызывается С, если нет С, то будет вызван А
# если нет А, то будет вызван класс object

some_object = D()
some_object.some_method()
